线段树总结
1）代码实现细节
  1）Tree数组开4*N就行
  2）所有数组从一开始，零弃而不用
  3）tag数组可以有多个，看你需要几种操作，需要注意优先级，比如重置和增加，应该先下发重置
      重置修改的题：贴海报，只用了修改操作，查询不一样
  4）函数流程
      1）bulit,单个元素返回，否则拆开，
      2）query,任务范围不变，主要任务范围把目前范围包含，立刻返回，
                否则先判断有无tag，有就down一下（多个标志分别判断），
                然后分裂统计，更新Tree数组（因为有down操作），
                答案返回，
      3）change(add,......)也就是区修操作，先判断是否被包含，如果是，打上标志，计算修改后的值，直接返回
                否则左右分裂，再通过tree[i]=tree[i<<1]+tree[i<<1|1];更新后返回
      4）down 这不是递归函数，主要为修改两个数组，tree和tag,
              对tree，计算它两个儿子区间修改后的值
              对tag,对儿子区间打标记，并记录值，
              取消自身标记（值和标志位都要清空）
2）线段树两个操作的时间复杂度分析，
  1）区修，如果可以以log(K)的复杂度把对应这个已划分区间的tree[i]修改，则复杂度为log(N)*log(K),
  2) 区查，如果可以以log(K)的复杂度通过两个儿子区间统计答案，则复杂度为log(N)*log(K);
3) 线段树维护常见信息
  1）区间最值
  2）区间累加和
  3) 维护边界值，每次只修改区间左右端点，然后汇总，
    例如P2184 地雷种数
    不在维护区间，而是通过修改端点实现，
4）线段树的性质
  1）线段树上的标记，子范围的标记早于父亲范围（如果两个都有标记），
  2）单点修改不需要标记
5）线段树拓展
  1）线段树二分，
      比如最常见的累加和和最大值，这些值明显有单调性，父范围上的值不小于子范围（元素非负），则在确定区间时可以用二分，一般是给一个端点，对另一个
      端点二分，例题 拓展111第二题，插花问题
  2）修改的势能复杂度分析
      这里的势能，目前我的理解是所有基点（原始数组代表的点）最大修改次数的总和（*基点的高度），
      比如经典线段树，每个基点可以无限修改，其势能为无限大，这样的线段树进行势能分析毫无意义，
      但是比如开方修改，维护区间和，开方是递减变化（对于整数），且操作次数常数及其小，这有了进行分析的基础
      通过额外维护信息，区分有势能的区间和无势能的区间（修改已经没有意义），所有修改的总复杂度不超过MAX（H*N*最大修改次数，M），
      例题 拓展111 第三题，luogu4145
      还有求模，求模每次一定会减少一半（或者不变）
  3）线段树维护端点信息（左右边界）；
      贪婪大陆
      查询区间内种类数，
      将每一种地雷看为一个有影响力的区间，影响从左端点开始，右端点结束
      就是看查询区间内有几个地雷区间产生影响且没有结束
      基础数组为每个点有几个开始端点，几个结束端点
      答案为 l r内 （1，r）的开始端点数目-（1，l-1）的结束端点数目
4)区间合并技巧
    在维护区间答案时，由子范围到父范围可能需要额外的信息，如果这个信息是范围信息（与子范围相关）
    而非全局信息，则可以再开线段树维护额外信息，达到维护答案信息的作用
    经典模型，区间最长1串，
    len线段树
    pre线段树
    suf线段树（后缀树）
