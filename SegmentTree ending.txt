线段树总结
1）代码实现细节
  1）Tree数组开4*N就行
  2）所有数组从一开始，零弃而不用
  3）tag数组可以有多个，看你需要几种操作
  4）函数流程
      1）bulit,单个元素返回，否则拆开，
      2）query,任务范围不变，主要任务范围把目前范围包含，立刻返回，
                否则先判断有无tag，有就down一下（多个标志分别判断），
                然后分裂统计，更新Tree数组（因为有down操作），
                答案返回，
      3）change(add,......)也就是区修操作，先判断是否被包含，如果是，打上标志，计算修改后的值，直接返回
                否则左右分裂，再通过tree[i]=tree[i<<1]+tree[i<<1|1];更新后返回
      4）down 这不是递归函数，主要为修改两个数组，tree和tag,
              对tree，计算它两个儿子区间修改后的值
              对tag,对儿子区间打标记，并记录值，
              取消自身标记（值和标志位都要清空）
2）线段树两个操作的时间复杂度分析，
  1）区修，如果可以以log(K)的复杂度把对应这个已划分区间的tree[i]修改，则复杂度为log(N)*log(K),
  2) 区查，如果可以以log(K)的复杂度通过两个儿子区间统计答案，则复杂度为log(N)*log(K);
3) 线段树维护常见信息
  1）区间最值
  1）区间累加和
4）线段树的性质
  1）线段树上的标记，子范围的标记早于父亲范围（如果两个都有标记），
  2）单点修改不需要标记
5）线段树拓展
