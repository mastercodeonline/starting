动态规划总结
  1）动态规划的思路来源（最基本，熟练后可以不需要）
      1）分解子问题递归调用-》记忆化搜索（加上结果数组）-》动态规划（调整顺寻）
  从顶到底-》从底到顶
  递归策略就是转移方程
      2）动态规划的条件限制和dp值设计
  一般情况下可能条件限制有多个，不如选取一个作为DP值，其余作为转移限制，
  例如CF——922D 二分+DP+区间限制
  选取k个数，（数组分段最大值和k个数的和）最大值最小，两个限制，k个数的限制，以及子段和，用双指针代表区间限制，而另一个不在考虑，循环完看是否
  合法，
  2）动态规划的顺序选择，考虑i位置，转移过程必须以i为边界，
  最佳旅行方案：不同票的持续时间不同，若从开始时间算，需要从后向前，反之；
  原因为无后续性，而边界不需考虑后续，自然为无后续；
  虽然i为边界；但初始点不一定为边界；
  比如范围内的种类数，此时初始点确实是边界
  但是如果求最佳顺序，可能初始点后面为边界（最长括号字串问题，每次i与最长可能点形成边界）
  3）动态规划底部转移
  初始转移对象容易确定的话
  若转移方式只有一种，很简单
  若有多种，一般为累加或者取最优

  
  转移对象不容易找（但一定在底部）
  转移方式一种（可以自己确定规律，指针等）
  转移方式多种且方式数一定为n（说明每个底部有n种情况）
  此时可以设置多个指针（每个指针代表一种转移方式）,只需在n种可能中选择，转移后更新指针
  比如丑数问题（因数只有2 3 5）； 

  还有一种为不断增加结尾元素，由部分元素（甚至单一元素）拓展出全部元素；
  这类问题中需要考虑前面的所有元素，新加入的元素可能不会改变目前的选择，即i为考虑的边界但可能不是选择的边界
  例如S1 S2最长子序列（可以不连续），二维问题，

  注意：维度不同，可能意义不同，可能一个维度代表选择范围，一个维度代表考虑范围
  比如左神必备069第五题

  对于二叉树（标准的分治模型，按左右子树分），看不出来的话，可以先设计递归方法，一定为左右子树的分治关系，在重新思考DP方法
  最简单的方法最为有效
4）常见DP类型
  1）区间DP，
  对角线填值初始化，
  结果结算与左右边界有关
  可能边界与中间值有区分进行DP，（比如气球累加最值，左神教程，以区间内气球都没爆，爆左右两个边界）
  2）树型DP
  递归形式DP，可以从叶到根(监视二叉树)，也可以从根到叶（比如078必备07）
  常见思路 1）根节点的选择与否 （比如树的直径）
           2) DFN序的性质，父亲节点与子节点的序号连续，可以辅助size数组，
           3）DFN序的存在使得DP可以用循环的方式遍历，而循环支持更复杂的做法，并且由于子树必连续，可以对特定子树
            操作（例如079第四题）
  3）数位DP，大体上按照高位到低位展开可能，适合小于大于等数值限制（可以结合位运算），原理位高位贡献一定大于低位贡献，在决定位结算答案（决定位前缀一定相等，或者已经结      算过答案，不影响当前答案，比如CF936_D）
           1）常见的变量设置，i 前i位 sum 总贡献 free(一般为0 1，有多余情况在加) 是否可以随便选（有时可以预处理简化） 
              yes(0或1) 前缀全部为0，或相等
              1.DP到第几位（ws），维护方法，开始时设为上限数的位数，然后每次向下枚举时-1s，当ws为0时输出sum并且退出枚举即可。

              2.DP中对获得的结果的记录（sum），维护方法，开始时设为0，当ws为1时判断此数是否为0，不是的话就+1s

              3.前导零（zero），维护方法，开始时设为0（有前导零），后面枚举时当当前位置不为0或枚举当前位前前导零即不为0时设为1（无前导零），其余时刻设为0即可。

              4，上一位数字（pr），维护方法，开始时设为0，后面直接传下去即可。

              5，枚举上限（rua）维护方法，这个没什么说的，如果枚举当前位前就没有达到上限或者是枚举的数字不是这一位上限时设为0（未达到上限），其余设为1（达到上限）即可。
           2）一般不用循环，记忆化加缓存就行，不然可能太麻烦，而每加一维，代价一般为 n 或者 logn ，维度可以多点
           3）例如必备084中，所有题几乎都有大小限制，不过准确一般为小于某数的限制（<N）,
              有等于可以N++，
              有大于（M<X<N），可以试试（f(<N)-f(<M)）,比如第三题
           4)前导零的处理，
              1）前缀可能减一    K的出现次数
              2）前导零标志  （标志位如果为零，一定要先处理填零的情况）
              3）不算0的情况，最后特判
  4）状压DP
          一种带有路径压缩的搜索，
          1）二进制状态压缩，01代表某个元素已经被取，
          2）其余信息说明
            1）dp[mask][i],表示目前在节点i上，例如CF——935 歌曲串烧
            2）dp[i][mask],不重复选择问题，i表示前i次选择，造成的选择状态，例如CF_938_H题，不重复范围防御塔
          3）冗余情况的处理，有些可能会影响答案，但有些不会，还会让我的答案更容易找到，
          防御塔设置，如果状态比我的选择多，其实是可以的，只是限制了后面选择，最大值不受影响，且答案转移到了固定位置
          这种情况下相当于DP维护的是符合我标准选择的子集的数目，比如 n个人 m个选择，不重复，【1111】【2】表示为2的子集的答案的
          最优情况

5）动态规划的时间复杂度范围
  取决与维度，一维最高n*n,二维最高n*n*n*n,
  有时需要前面的固定数目元素，有时需要前面部分甚至全部元素（列 行 底）
  优化方法(因为存在优化，所以可以先不考虑数据范围，一般为最值问题)
  1）单调队列
  2）map+num[]数组，CF922D;
