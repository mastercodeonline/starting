搜索总结（主要为暴力模拟搜索和剪枝技巧）

搜索的本质（在选择过程中转移状态）
有些只需在一个节点选择移动到哪个节点，其余节点状态（状态包括节点在整体的相对位置， 以及节点的转移）容易得到且方便表示
此时只需记录一个节点和其他需要的信息
而有些需要记录整个状态，luoguP1379，9宫格华容道问题，每次状态转移与上次移动节点（关系不大），只与0的位置有关，而其余节点没有固定的相对关系
而整体与整体间的转移关系确定，因此可以用字符串（有时可以2进制表示），用整体为搜索节点（这里搜索节点与整体节点不同，应该为搜索解答树的一个节点，表示搜索过程整体
的一个状态，不过有些时候，整体状态可以用整体节点表示而已）


1）主要搜索方式 DFS BFS
最优搜索以及种类数搜索
DFS可以适用加深迭代搜索控制深度
BFS可以用双向广搜（知道终点）减少搜索节点数
搜索过程中要注意完全相同（节点关系完全相同）的状态（种类数搜素可以用记忆化搜索，最优搜索可以用去重）

A*需要一个记录起点到目前的最短距离数组（支持更新操作，直到找到目标）
估价函数的设计 1）曼哈顿距离 和 直线距离
              2）先跑无限制（限制少）的最短路，记录数据作为估价函数

IDA*是用BFS进行DFS，需要用一个数组节点的第一次发现时的深度（一次搜多层，但深度有限制），用deep[i]+f[i]限制深度，同样为优先队列实现
还有一种maxdepth从小到大，一旦（f[i]+deep[i]>maxdepth）停止递归，返回
需要注意如果没有路径，非常容易超时

01BFS与类联通
解决方法 建立虚拟节点，虚拟节点到其中联通节点的权值为0
01BFS利用双端队列（优先结算0边）
正常的BFS如果先算0边一样可以

折半搜索加速
把深度折半，两边单独进行DFS，到每次的最低层时用数组记录所需信息
最后综合两次的数组，得到结果
特点深度不会超过40~50
例题 luogu进阶搜索P4799
2）模拟类型 有明显层数递进（这种一般好模拟，按每层的选择递进）
            
            无次序规则分组，要求每组达标（比如把数组合并为几个相同的数）
            这种一般一组一组分， int k为处理的组数 ，int rest 为组内剩余要求 target 每组的整体要求
            处理需要回退的状态
            可以利用v[]或者num[]数组
            v[]++
            dfs()
            v[]--

            选择范围（连续），每次递进，可能范围改变（且只需上一次的范围）
            这种定义 l r,按照题意，更新 l r即可
            例如CF913D
3）剪枝技巧
剪掉完全不合理的分支，比如求最小累积，结果太大（远大于期望），直接停止

遇到部分最优情况后不再进行选择，直接回退（如果分支为答案，可以利用，如果不是，连最优都不是，整个分支一定不是）
比如 凑木棒 最开始一定选最长的（开始的最优） 如果存在直接凑成的部分（部分选择最优），一定最优
这些都要直接回退，不在选择
4）简单状态表示和回溯
去重操作 v[]数组   set<data> s(只要考虑存不存在，不需要其他信息)  map<data ,other> m(需要其他信息)
双向广搜 A* IDA*的去重
双向广搜中每个节点只访问一次
A*中每个节点可以重复访问（一般也不会访问过多，算法过程决定），直到找到目的地
IDA*中
Dijatsla算法中出队只有一次，以后不在对同一节点操作

配合数组更新整体状态
