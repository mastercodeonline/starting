线段树总结
1）代码实现细节
  1）Tree数组开4*N就行
  2）所有数组从一开始，零弃而不用
  3）tag数组可以有多个，看你需要几种操作，需要注意优先级，比如重置和增加，应该先下发重置
  4）函数流程
      1）bulit,单个元素返回，否则拆开，
      2）query,任务范围不变，主要任务范围把目前范围包含，立刻返回，
                否则先判断有无tag，有就down一下（多个标志分别判断），
                然后分裂统计，更新Tree数组（因为有down操作），
                答案返回，
      3）change(add,......)也就是区修操作，先判断是否被包含，如果是，打上标志，计算修改后的值，直接返回
                否则左右分裂，再通过tree[i]=tree[i<<1]+tree[i<<1|1];更新后返回
      4）down 这不是递归函数，主要为修改两个数组，tree和tag,
              对tree，计算它两个儿子区间修改后的值
              对tag,对儿子区间打标记，并记录值，
              取消自身标记（值和标志位都要清空）
2）线段树两个操作的时间复杂度分析，
  1）区修，如果可以以log(K)的复杂度把对应这个已划分区间的tree[i]修改，则复杂度为log(N)*log(K),
  2) 区查，如果可以以log(K)的复杂度通过两个儿子区间统计答案，则复杂度为log(N)*log(K);
3) 线段树维护常见信息
  1）区间最值
  1）区间累加和
4）线段树的性质
  1）线段树上的标记，子范围的标记早于父亲范围（如果两个都有标记），
  2）单点修改不需要标记
5）线段树拓展
  1）线段树二分，
      比如最常见的累加和和最大值，这些值明显有单调性，父范围上的值不小于子范围（元素非负），则在确定区间时可以用二分，一般是给一个端点，对另一个
      端点二分，例题 拓展111第二题，插花问题
  2）修改的势能复杂度分析
      这里的势能，目前我的理解是所有基点（原始数组代表的点）最大修改次数的总和（*基点的高度），
      比如经典线段树，每个基点可以无限修改，其势能为无限大，这样的线段树进行势能分析毫无意义，
      但是比如开方修改，维护区间和，开方是递减变化（对于整数），且操作次数常数及其小，这有了进行分析的基础
      通过额外维护信息，区分有势能的区间和无势能的区间（修改已经没有意义），所有修改的总复杂度不超过MAX（H*N*最大修改次数，M），
      例题 拓展111 第三题，luogu4145
